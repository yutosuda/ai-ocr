# AI-OCR サーバーアーキテクチャ詳細設計

## 1. 概要

AI-OCR システムは、文書からデータを抽出する AI ベースのサービスを提供するシステムです。このドキュメントでは、システムのサーバーアーキテクチャ、コンポーネント構成、ネットワーク設計、データフロー、スケーラビリティ戦略などについて詳細に説明します。

## 2. アーキテクチャ原則

AI-OCR システムのアーキテクチャは、以下の原則に基づいて設計されています：

1. **ベンダー非依存性**: 特定のクラウドプロバイダーやサービスに依存しない設計
2. **コンテナ化**: すべてのコンポーネントをコンテナとして実装
3. **マイクロサービス指向**: 機能ごとに分離された独立したサービス
4. **スケーラビリティ**: 負荷に応じて水平・垂直にスケール可能
5. **高可用性**: 単一障害点のない冗長設計
6. **セキュリティ**: すべての通信とデータの暗号化
7. **監視可能性**: 包括的なログ記録とメトリクス収集

## 3. システム構成図

AI-OCR システムは以下のコンポーネントから構成されています：

```
┌─────────────────────────────────────────────────────────────────────┐
│                         Docker Environment                           │
│                                                                     │
│  ┌─────────────┐       ┌─────────────┐      ┌─────────────────┐    │
│  │             │       │             │      │                 │    │
│  │  APIサービス │◄─────►│ プロセッサー │◄────►│  データベース   │    │
│  │  (FastAPI)  │       │ サービス    │      │  (PostgreSQL)  │    │
│  │             │       │             │      │                 │    │
│  └──────┬──────┘       └──────┬──────┘      └─────────────────┘    │
│         │                     │                                     │
│         │                     │                                     │
│         ▼                     ▼                                     │
│  ┌─────────────┐       ┌─────────────┐                              │
│  │             │       │             │                              │
│  │  キャッシュ   │       │ オブジェクト │                              │
│  │  (Redis)    │       │ ストレージ   │                              │
│  │             │       │  (MinIO)   │                              │
│  └─────────────┘       └─────────────┘                              │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

## 4. コンポーネント詳細

### 4.1. API サービス

**コンテナ名**: `api`

**ベースイメージ**: `python:3.9-slim`

**責務**:

- 外部システムとのインターフェース提供
- 認証と認可の処理
- リクエストのバリデーション
- ドキュメント管理 API の提供
- ジョブ管理 API の提供
- 抽出データ管理 API の提供

**設定**:

- ポート: 8000 (HTTP)
- ヘルスチェックエンドポイント: `/health`
- 依存サービス: PostgreSQL, Redis, MinIO

**スケーリング戦略**:

- 水平スケーリング: 複数のインスタンスを起動し、ロードバランサーを使用
- 垂直スケーリング: コンテナのリソース割り当てを増加

**リソース要件**:

- CPU: 1 コア (最小), 2 コア (推奨)
- メモリ: 1GB (最小), 2GB (推奨)
- ディスク: 1GB (最小)

### 4.2. プロセッサーサービス

**コンテナ名**: `processor`

**ベースイメージ**: `python:3.9-slim`

**責務**:

- ドキュメントの解析
- AI モデル (GPT-4o) との連携
- データ抽出処理
- 抽出データの検証
- 処理結果の保存

**設定**:

- ポート: 内部通信のみ (8080)
- ヘルスチェックエンドポイント: `/health`
- 依存サービス: PostgreSQL, Redis, MinIO

**スケーリング戦略**:

- 水平スケーリング: ワーカープロセス数を増加 (`PROCESSOR_WORKERS` 環境変数)
- 垂直スケーリング: コンテナのリソース割り当てを増加

**リソース要件**:

- CPU: 2 コア (最小), 4 コア (推奨)
- メモリ: 2GB (最小), 4GB (推奨)
- ディスク: 1GB (最小)

### 4.3. データベース

**コンテナ名**: `db`

**イメージ**: `postgres:14-alpine`

**責務**:

- 永続データの保存
- トランザクション処理
- データの整合性保証

**設定**:

- ポート: 5432
- ボリューム: `postgres-data` (永続化ストレージ)
- 初期化スクリプト: `/docker-entrypoint-initdb.d`

**スケーリング戦略**:

- 垂直スケーリング: リソース割り当ての増加
- 読み取りレプリカの追加 (将来的な拡張)

**リソース要件**:

- CPU: 1 コア (最小), 2 コア (推奨)
- メモリ: 1GB (最小), 2GB (推奨)
- ディスク: 10GB (最小), 20GB (推奨)

### 4.4. キャッシュ/キュー

**コンテナ名**: `redis`

**イメージ**: `redis:7-alpine`

**責務**:

- 処理キューの管理
- 一時データのキャッシュ
- サービス間通信の仲介

**設定**:

- ポート: 6379
- 永続化: AOF (Append Only File)
- ボリューム: `redis-data`

**スケーリング戦略**:

- 垂直スケーリング: リソース割り当ての増加

**リソース要件**:

- CPU: 0.5 コア (最小), 1 コア (推奨)
- メモリ: 512MB (最小), 1GB (推奨)
- ディスク: 1GB (最小)

### 4.5. オブジェクトストレージ

**コンテナ名**: `minio`

**イメージ**: `minio/minio`

**責務**:

- 文書ファイルの保存
- 処理結果の保存
- バイナリデータの管理

**設定**:

- ポート: 9000 (API), 9001 (コンソール)
- ボリューム: `minio-data`
- バケット: `documents` (自動作成)

**スケーリング戦略**:

- 垂直スケーリング: リソース割り当ての増加
- 分散デプロイメント (将来的な拡張)

**リソース要件**:

- CPU: 1 コア (最小), 2 コア (推奨)
- メモリ: 1GB (最小), 2GB (推奨)
- ディスク: 20GB (最小), 100GB (推奨)

## 5. ネットワーク設計

### 5.1. コンテナネットワーク

AI-OCR システムは Docker Compose が自動作成するデフォルトネットワークを使用します。このネットワークは以下の特性を持っています：

- ブリッジネットワークタイプ
- コンテナ間の通信が可能
- ホストからコンテナへのポートマッピング
- 内部 DNS 解決 (コンテナ名による相互参照)

### 5.2. 通信フロー

1. **外部 → API サービス**:

   - ポート 8000 を介した HTTP/HTTPS リクエスト
   - 認証トークンによるアクセス制御

2. **API サービス → データベース**:

   - PostgreSQL プロトコル (ポート 5432)
   - 認証情報による接続

3. **API サービス → Redis**:

   - Redis プロトコル (ポート 6379)
   - キャッシュとキュー操作

4. **API サービス → MinIO**:

   - S3 互換 API (ポート 9000)
   - 認証情報によるアクセス制御

5. **API サービス → プロセッサーサービス**:

   - 内部 HTTP 通信
   - ジョブ登録とステータス確認

6. **プロセッサーサービス → データベース/Redis/MinIO**:
   - 各サービスへの直接接続
   - 処理状態の更新と結果の保存

### 5.3. セキュリティ考慮事項

- **コンテナ間通信**: Docker 内部ネットワークで保護
- **外部通信**: TLS/SSL による暗号化 (プロダクション環境)
- **認証**: 各サービスの認証情報は環境変数で提供
- **最小権限**: 各サービスに必要最小限のアクセス権を付与

## 6. データフロー

### 6.1. 文書アップロードフロー

```
┌──────────┐    ┌───────────┐    ┌─────────┐    ┌───────────┐
│          │    │           │    │         │    │           │
│ クライアント │───►│ APIサービス │───►│  MinIO  │◄───┤ データベース │
│          │    │           │    │         │    │           │
└──────────┘    └─────┬─────┘    └─────────┘    └───────────┘
                      │
                      ▼
                ┌───────────┐
                │           │
                │   Redis   │
                │           │
                └─────┬─────┘
                      │
                      ▼
                ┌───────────┐
                │           │
                │プロセッサー │
                │           │
                └───────────┘
```

1. クライアントが API サービスに文書をアップロード
2. API サービスが文書を MinIO に保存
3. API サービスが文書メタデータをデータベースに保存
4. API サービスが処理ジョブを Redis キューに追加
5. プロセッサーサービスがキューからジョブを取得して処理

### 6.2. データ抽出フロー

```
┌───────────┐    ┌─────────┐    ┌───────────┐    ┌─────────┐
│           │    │         │    │           │    │         │
│ プロセッサー │───►│  MinIO  │───►│ LangChain/ │───►│ GPT-4o │
│           │    │         │    │ LangGraph │    │         │
└─────┬─────┘    └─────────┘    └───────────┘    └─────────┘
      │
      ▼
┌───────────┐
│           │
│ データベース │
│           │
└───────────┘
```

1. プロセッサーサービスが MinIO から文書を取得
2. LangChain/LangGraph パイプラインが文書を解析
3. GPT-4o モデルを使用してデータを抽出
4. 抽出結果を検証して整形
5. 結果をデータベースに保存

### 6.3. データ取得フロー

```
┌──────────┐    ┌───────────┐    ┌───────────┐
│          │    │           │    │           │
│ クライアント │───►│ APIサービス │───►│ データベース │
│          │    │           │    │           │
└──────────┘    └───────────┘    └───────────┘
```

1. クライアントが API サービスに抽出データを要求
2. API サービスがデータベースから情報を取得
3. API サービスがレスポンスを整形してクライアントに返す

## 7. スケーラビリティ戦略

### 7.1. 水平スケーリング

- **API サービス**: 複数インスタンスの起動とロードバランシング
- **プロセッサーサービス**: 複数ワーカーによる並列処理
- **将来的な拡張**: Kubernetes によるオーケストレーション

### 7.2. 垂直スケーリング

- 各コンテナに割り当てるリソース (CPU/メモリ) の増加
- 高性能なハードウェアへの移行

### 7.3. データベーススケーリング

- 読み取り/書き込み分離
- シャーディング (将来的な大規模データ対応)
- 接続プーリングの最適化

### 7.4. 負荷分散

- ジョブキューによる処理の分散
- バックグラウンド処理とタスク優先度の設定
- タイムアウトと再試行メカニズムの実装

## 8. 高可用性設計

### 8.1. 冗長化

- **アプリケーションレベル**: 複数のサービスインスタンス
- **データレベル**: データベースのバックアップと復元
- **ストレージレベル**: MinIO の冗長構成 (将来的な実装)

### 8.2. 障害検出と自動復旧

- ヘルスチェックによる障害検出
- 自動再起動ポリシー (`restart: unless-stopped`)
- 処理の冪等性確保によるリカバリー

### 8.3. バックアップ戦略

- データベース: 定期的なダンプとスナップショット
- MinIO: バケットのバックアップ
- 設定ファイル: バージョン管理システムによる管理

## 9. モニタリングと運用

### 9.1. ログ管理

- 構造化ログの生成
- ログレベルの設定 (`API_LOG_LEVEL`)
- 将来的な集中ログ収集の検討

### 9.2. メトリクス収集

- API サービスのリクエスト統計
- プロセッサーサービスの処理性能
- リソース使用率 (CPU, メモリ, ディスク)

### 9.3. アラート設定

- クリティカルエラーの通知
- リソース使用率の閾値アラート
- サービス停止の検出

## 10. ベンダーロックイン回避戦略

AI-OCR システムは特定のベンダーやクラウドプロバイダーへの依存を避けるために以下の戦略を採用しています：

### 10.1. コンテナ化とポータビリティ

- **Docker コンテナ**: すべてのサービスをコンテナ化し、環境間の一貫性を確保
- **Docker Compose**: インフラストラクチャをコードとして管理
- **環境変数による設定**: 環境固有の設定を外部化

### 10.2. オープンソースソフトウェアの使用

- **PostgreSQL**: 標準的なオープンソースデータベース
- **Redis**: 広く採用されているキャッシュシステム
- **MinIO**: S3 互換 API を提供するオープンソースストレージ
- **FastAPI**: 標準的な HTTP フレームワーク

### 10.3. 標準 API とプロトコル

- **RESTful API**: 広く採用されている標準
- **S3 互換 API**: クラウド非依存のストレージインターフェース
- **標準データベースプロトコル**: 特定のプロバイダーに依存しない接続

### 10.4. 抽象化レイヤーの使用

- **サービス抽象化**: 外部サービスへのアクセスを抽象レイヤーで分離
- **設定の分離**: 環境固有の設定を分離
- **インターフェース指向設計**: 実装詳細を隠蔽

### 10.5. プロバイダー移行戦略

- 必要に応じて異なる環境に移行可能な設計
- 特定のクラウドサービスへの過度の依存を避ける
- 移行コストを最小化するための設計上の配慮

## 11. デプロイメントガイド

### 11.1. 前提条件

- Docker と Docker Compose のインストール
- 環境変数ファイル (`.env.local`) の準備
- 十分なディスク容量とメモリの確保

### 11.2. 初回デプロイ

1. リポジトリのクローン:

   ```bash
   git clone <repository-url>
   cd ai-ocr
   ```

2. 環境設定ファイルの準備:

   ```bash
   cp .env.local.example .env.local
   # 編集して適切な値を設定
   ```

3. コンテナの構築と起動:

   ```bash
   docker-compose up --build -d
   ```

4. 初期化の確認:
   ```bash
   docker-compose logs -f
   ```

### 11.3. アップデート手順

1. 最新コードの取得:

   ```bash
   git pull
   ```

2. コンテナの再構築と再起動:
   ```bash
   docker-compose down
   docker-compose up --build -d
   ```

### 11.4. バックアップ手順

1. データベースのバックアップ:

   ```bash
   docker-compose exec db pg_dump -U postgres ai_ocr > backup/db_$(date +%Y%m%d).sql
   ```

2. MinIO データのバックアップ:
   ```bash
   # MinIO クライアントを使用したバックアップ
   ```

## 12. トラブルシューティング

- **API サービスに接続できない**: ポートマッピングと起動ステータスを確認
- **プロセッサーがジョブを処理しない**: Redis 接続とキューの状態を確認
- **ファイルアップロードエラー**: ディスク容量と MinIO の状態を確認
- **データベース接続エラー**: PostgreSQL の起動状態と認証情報を確認

## 13. 結論

AI-OCR システムのサーバーアーキテクチャは、ベンダー非依存性、スケーラビリティ、保守性を重視して設計されています。Docker ベースのコンテナ化により、さまざまな環境で一貫したデプロイメントが可能であり、必要に応じて水平・垂直にスケールすることができます。各コンポーネントは明確な責務を持ち、適切に連携して動作することで、効率的なドキュメント処理と高精度なデータ抽出を実現します。
